<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Background with Draggable Objects</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
            cursor: grab;
        }
        #control-panel {
        position: absolute;
        top: 10px;
        left: 10px;
        background: white;
        padding: 10px;
        border-radius: 5px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
  <div id="control-panel">
    <button onclick="addCameraIcon()">Add Camera</button>
    <button onclick="addLockIcon()">Add Lock</button>
</div>
    <canvas id="myCanvas"></canvas>
    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const background = new Image();
        background.src = 'image.png'; // bg

        let scale = 1; 
        let offsetX = 0, offsetY = 0;
        let isPanning = false;
        let lastX, lastY;


        let camera_icons = [
          { x: 100, y: 100, width: 50, height: 50, color: 'red', dragging: false }
        ];
        let lock_icons = [
          { x: 300, y: 200, width: 50, height: 50, color: 'blue', dragging: false }
        ];

        let draggedObject = null;

        background.onload = function() {
            draw();
        };

        function draw() {
            ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
            ctx.clearRect(-offsetX / scale, -offsetY / scale, canvas.width / scale, canvas.height / scale);
            ctx.drawImage(background, 0, 0, background.width, background.height);



            // Draw camera
            camera_icons.forEach(obj => {
              ctx.fillStyle = obj.color;
              ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
            })

            // Draw lock
            lock_icons.forEach(obj => {
              ctx.fillStyle = obj.color;
              ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
            })
        }

        function getMousePos(evt) {
            return {
                x: (evt.clientX - offsetX) / scale,
                y: (evt.clientY - offsetY) / scale,
            };
        }

        canvas.addEventListener('mousedown', (e) => {
            let mouse = getMousePos(e);
            draggedObject = [...camera_icons, ...lock_icons].find(obj =>
                mouse.x >= obj.x && mouse.x <= obj.x + obj.width &&
                mouse.y >= obj.y && mouse.y <= obj.y + obj.height
            );

            if (draggedObject) {
                draggedObject.dragging = true;
            } else {
                isPanning = true;
                lastX = e.clientX;
                lastY = e.clientY;
            }
            canvas.style.cursor = "grabbing";
        });

        canvas.addEventListener('mousemove', (e) => {
            let mouse = getMousePos(e);

            if (draggedObject && draggedObject.dragging) {
                draggedObject.x = mouse.x - draggedObject.width / 2;
                draggedObject.y = mouse.y - draggedObject.height / 2;
                draw();
            } else if (isPanning) {
                let dx = e.clientX - lastX;
                let dy = e.clientY - lastY;
                offsetX += dx;
                offsetY += dy;
                lastX = e.clientX;
                lastY = e.clientY;
                draw();
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (draggedObject) draggedObject.dragging = false;
            isPanning = false;
            draggedObject = null;
            canvas.style.cursor = "grab";
        });

        canvas.addEventListener('mouseleave', () => {
            isPanning = false;
            if (draggedObject) draggedObject.dragging = false;
            draggedObject = null;
            canvas.style.cursor = "grab";
        });

        // Zoom with scroll
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            let zoomIntensity = 0.1;
            let newScale = scale + (e.deltaY > 0 ? -zoomIntensity : zoomIntensity);
            newScale = Math.max(0.5, Math.min(2, newScale));

            let mouseX = e.clientX - canvas.offsetLeft;
            let mouseY = e.clientY - canvas.offsetTop;
            offsetX -= (mouseX - offsetX) * (newScale - scale);
            offsetY -= (mouseY - offsetY) * (newScale - scale);

            scale = newScale;
            draw();
        });


        function addCameraIcon() {
        camera_icons.push({
            x: (canvas.width / 2 - 25) / scale, 
            y: (canvas.height / 2 - 25) / scale,  
            width: 50, 
            height: 50, 
            color: 'red', 
            dragging: false
        });
        draw();
    }

        function addLockIcon() {
        lock_icons.push({
            x: (canvas.width / 2 - 25) / scale, 
            y: (canvas.height / 2 - 25) / scale,
            width: 50, 
            height: 50, 
            color: 'blue', 
            dragging: false
        });
        draw();
}

    </script>
</body>
</html>
