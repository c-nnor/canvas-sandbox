<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Background with Draggable Objects</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
            cursor: grab;
        }
        #control-panel {
            position: absolute;
            display: flex;
            top: 10px;
            left: 10px;
            background: rgb(37, 37, 37);
            padding: 10px;
            border-radius: 5px;
            border:solid 0.1px rgb(66, 66, 66);
            color:white;
            transition: opacity 0.3s ease, transform 0.3s ease-in-out;

        }
        .btnControl {
            margin-left: 10px;
        }

        #btnAddLock{
            background-image: url(lock_v2.svg);
            width:50px;
            height:50px;
            background-size:30px 30px; 
            background-position: center;
            border-radius:10px;
            background-repeat: no-repeat;
            cursor:pointer;
            background-color: rgb(0, 0, 0);
            transition: 0.2s ease-in-out;
        }

        #btnAddLock:hover{
            background-color: rgb(201, 201, 201);
        }


        #btnAddCam{
            background-image: url(camera_v2.svg);
            width:50px;
            height:50px;
            background-size: 50px 50px; 
            background-position: center;
            border-radius:10px;
            content: "Click to add a cam";
            background-repeat: no-repeat;
            cursor:pointer;
            background-color: rgb(0, 0, 0);
            transition: 0.2s ease-in-out;
        }

        #btnAddCam:hover{
            background-color: rgb(201, 201, 201);
        }

        #btnHelp{
            background-image: url(btn_help.svg);
            width:30px;
            height:30px;
            background-size: contain; 
            background-position: center;
            border-radius:40px;
            content: "Click to add a cam";
            background-repeat: no-repeat;
            cursor:pointer;
            background-color: transparent;
            transition: 0.2s ease-in-out;
            border:0;
            box-shadow: 0.2px 0.2px 0.2px;
            transition: 0.3s ease-in-out;
            overflow:hidden;
        }

        #btnHelp:hover{
            background-color: rgb(255, 255, 255);
        }

        #helpPopup{
            font-family: Arial, Helvetica, sans-serif;
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            margin: auto;
            width: 50%;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 100;
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 99;
        }

        #topHelpContent{
            display:flex;
            justify-content: space-between;
            align-items: center;
            padding:0 5%;
        }
        #topHelpContent p{
            font-size:2rem;
            font-weight:bold;
            margin:0;
        }

        #btnPopupClose{
            cursor:pointer;
        }


        .context-menu {
            display: none;
            position: absolute;
            background: black;
            border: 1px solid #333;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            z-index: 1000;
            font-family: Arial, sans-serif;
        }

        .context-menu ul {
            list-style: none;
            margin: 0;
            padding: 5px;
        }

        .context-menu ul li {
            padding: 8px 15px;
            cursor: pointer;
            transition: background 0.2s;
            color: blue;
        }

        .context-menu ul li:hover {
            background: #222;
        }

    </style>
</head>
<body>
    <!-- Right clicking menu -->
    <div id="contextMenu" class="context-menu">
        <ul>
            <li onclick="deleteIcon()">Delete</li>
            <li onclick="option2()">Option2</li>
            <li onclick="option3()">Option3</li>
        </ul>
    </div>

    <div id="overlay"></div>
    <div id="helpPopup">
        <div id="topHelpContent">
            <h2>App Help</h2>
            <p id="btnPopupClose">X</p>
        </div>
        <ul>
            <li>Upload an image using the choose file in the top right</li>
            <li>Zoom in using your mouse wheel</li>
            <li>Move around the image by clicking and dragging</li>
            <li>Add Security Icons by clicking the buttons at the top</li>
            <li>If you forget anything just click the ?   button</li>
        </ul>
    </div>
    <div id="control-panel">
        <input type="file" id="imgInput" onchange="changeImage(event)" accept="image/*">
        <button id="btnAddCam" class="btnControl" onclick="addCameraIcon()" title="Click to add a camera icon"></button>
        <button id="btnAddLock" class="btnControl" onclick="addLockIcon()" title="Click to add a lock icon"></button>
        <button id="btnHelp" class="btnControl" onclick="openHelpPopup()"></button>
    </div>
    <canvas id="myCanvas"></canvas>
    <script>
        class CameraIcon {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 75;
                this.height = 75;
                this.dragging = false;
                this.image = new Image();
                this.image.src = 'camera_v2.svg';
            }

            draw(ctx) {
                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
            }

            isMouseOver(mouseX, mouseY) {
                return mouseX >= this.x && mouseX <= this.x + this.width &&
                       mouseY >= this.y && mouseY <= this.y + this.height;
            }
        }

        class LockIcon {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 50;
                this.height = 50;
                this.dragging = false;
                this.image = new Image();
                this.image.src = 'lock_v2.svg';
            }

            draw(ctx) {
                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
            }

            isMouseOver(mouseX, mouseY) {
                return mouseX >= this.x && mouseX <= this.x + this.width &&
                       mouseY >= this.y && mouseY <= this.y + this.height;
            }
        }



        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const background = new Image();
        background.src = 'floorplan.png'; // Background image

        let scale = 1, offsetX = 0, offsetY = 0;
        let isPanning = false;
        let lastX, lastY;
        let draggedObject = null;
        // Vars for the last valid position of an icon
        let lastValidX, lastValidY;
        let cameraIcons = [new CameraIcon(100, 100)];
        let lockIcons = [new LockIcon(300, 200)];

        background.onload = function () {
            draw();
        };

        function draw() {
            ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
            ctx.clearRect(-offsetX / scale, -offsetY / scale, canvas.width / scale, canvas.height / scale);
            ctx.drawImage(background, 0, 0, background.width, background.height);

            // Draw icons
            cameraIcons.forEach(icon => icon.draw(ctx));
            lockIcons.forEach(icon => icon.draw(ctx));
        }

        function getMousePos(evt) {
            return {
                x: (evt.clientX - offsetX) / scale,
                y: (evt.clientY - offsetY) / scale,
            };
        }

        canvas.addEventListener('mousedown', (e) => {
            let mouse = getMousePos(e);

            draggedObject = [...cameraIcons, ...lockIcons].find(obj => obj.isMouseOver(mouse.x, mouse.y));

            if (draggedObject) {
                draggedObject.dragging = true;
            } else {
                isPanning = true;
                lastX = e.clientX;
                lastY = e.clientY;
                document.getElementById('control-panel').style.opacity = "0";
            }
            canvas.style.cursor = "grabbing";
        });

        canvas.addEventListener('mousemove', (e) => {
            let mouse = getMousePos(e);

            if (draggedObject && draggedObject.dragging) {
                draggedObject.x = mouse.x - draggedObject.width / 2;
                draggedObject.y = mouse.y - draggedObject.height / 2;

                // Get the full array of icons for manipulation
                let allIcons = cameraIcons.concat(lockIcons);
                // 
                if (checkOverlap(draggedObject, allIcons)){
                    // If an overlap is detected revert to last valid position
                    draggedObject.x = lastValidX;
                    draggedObject.y = lastValidY;
                }else{
                    lastValidX = draggedObject.x;
                    lastValidY = draggedObject.y;
                }
                draw();
            } else if (isPanning) {
                let dx = e.clientX - lastX;
                let dy = e.clientY - lastY;
                offsetX += dx;
                offsetY += dy;
                lastX = e.clientX;
                lastY = e.clientY;
                draw();
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (draggedObject) draggedObject.dragging = false;
            isPanning = false;
            draggedObject = null;
            document.getElementById('control-panel').style.opacity = "1";
            canvas.style.cursor = "grab";
        });

        canvas.addEventListener('mouseleave', () => {
            isPanning = false;
            if (draggedObject) draggedObject.dragging = false;
            draggedObject = null;
            canvas.style.cursor = "grab";
        });

        // Zoom with scroll
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            let zoomIntensity = 0.1;
            let newScale = scale + (e.deltaY > 0 ? -zoomIntensity : zoomIntensity);
            newScale = Math.max(0.3, Math.min(2, newScale));

            let mouseX = e.clientX - canvas.offsetLeft;
            let mouseY = e.clientY - canvas.offsetTop;
            offsetX -= (mouseX - offsetX) * (newScale - scale);
            offsetY -= (mouseY - offsetY) * (newScale - scale);

            scale = newScale;
            draw();
        });

        // Reference for me - Please dont delete yet - OT
        // ----------------------------------------------

        // // deleting an icon
        // let deleteMode = false;

        // canvas.addEventListener('contextmenu', (e) => {
        //     e.preventDefault(); // Prevent the default context menu

        //     let mouse = getMousePos(e);

        //     // Checking if click was on a camera icon
        //     let clickedCamera = cameraIcons.find((obj) => obj.isMouseOver(mouse.x, mouse.y));
        //     if (clickedCamera) {
        //         // Removing the clicked camera icon
        //         cameraIcons = cameraIcons.filter((obj) => obj !== clickedCamera);
        //         draw(); // Redrawing the container
        //         return;
        //     }
        
        //     // Checking if clicked was on a lock icon
        //     let clickedLock = lockIcons.find((obj) => obj.isMouseOver(mouse.x, mouse.y));
        //     if (clickedLock) {
        //         // Removing the clicked lock icon
        //         lockIcons = lockIcons.filter((obj) => obj !== clickedLock);
        //         draw(); // Redrawing the container
        //         return;
        //     }
        // });


        let selectedIcon = null; // Store the selected icon

        document.addEventListener("contextmenu", (e) => {
            e.preventDefault(); // Preventing the systems default right-click menu

            let mouse = getMousePos(e);
            selectedIcon = [...cameraIcons, ...lockIcons].find(obj => obj.isMouseOver(mouse.x, mouse.y));

            if (selectedIcon) {
                // Showing the menu where the mouse is on the screen
                const menu = document.getElementById("contextMenu");
                menu.style.left = `${e.pageX}px`;
                menu.style.top = `${e.pageY}px`;
                menu.style.display = "block";
            } 
            else {
                closeContextMenu(); // closing the menu when the 
            }
        });// Context Menu END

        // Function to close menu when clicking elsewhere
        document.addEventListener("click", () => {
            closeContextMenu();
        });

        // Function to close menu on icon
        function closeContextMenu() {
            document.getElementById("contextMenu").style.display = "none";
        }

        // Deleting the selected icon
        function deleteIcon() {
            if (selectedIcon) {
                cameraIcons = cameraIcons.filter(obj => obj !== selectedIcon);
                lockIcons = lockIcons.filter(obj => obj !== selectedIcon);
                draw();
                closeContextMenu();
            }
        }

        // Menu option 2 - Likely going to be changing icon/class
        function option2() {
            console.log("Option 2 - Change icon option");
            closeContextMenu();
        }

        // Menu option 3 - likely going to be changing the colour/ grouping
        function option3() {
            console.log("Option 3 - Potenital change colour/ grouping option");
            closeContextMenu();
        }


        function addCameraIcon() {
            const newCamera = new CameraIcon((canvas.width / 2 - 25) / scale, (canvas.height / 2 - 25) / scale);
            cameraIcons.push(newCamera);
            draw();
        }

        function addLockIcon() {
            const newLock = new LockIcon((canvas.width / 2 - 25) / scale, (canvas.height / 2 - 25) / scale);
            lockIcons.push(newLock);
            draw();
        }

        function changeImage(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    background.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        };

        function openHelpPopup() {
            let overlay = document.getElementById("overlay");
            let helpPopup = document.getElementById("helpPopup");
                if (overlay.style.display === "none" || overlay.style.display === "") {
                    overlay.style.display = "block";
                    helpPopup.style.display = "block";
                } else {
                    overlay.style.display = "none";
                    helpPopup.style.display = "none";
                }
            };

            document.getElementById("btnPopupClose").addEventListener('click', function(){
                document.getElementById('overlay').style.display = "none";
                document.getElementById("helpPopup").style.display = "none";
            });

            // Close popup when clicking on the overlay
            document.getElementById("overlay").addEventListener("click", function() {
                this.style.display = "none";
                document.getElementById("helpPopup").style.display = "none";
            });

            window.onload = function () {
                console.log("Window loaded...")
                openHelpPopup(); // Call the function to show the popup when the page loads
            };

            // Logic for checking icons don't overlap
            function checkOverlap(currentIcon, existingIcons){
                console.log("\nChecking overlap...")
                for(let icon of existingIcons){
                    if(currentIcon !== icon &&
                        // check the x and y axis dont match
                        // We can do this by checking the x value of existing icons plus the width is less than the selected icons x value plus its with
                        currentIcon.x < icon.x + icon.width &&
                        currentIcon.x + currentIcon.width > icon.x &&
                        currentIcon.y < icon.y + icon.height &&
                        currentIcon.y + currentIcon.height > icon.y
                    ){
                        // There is an overlap so returning true
                        return true;
                    }
                }
                // There is no overlap
                return false;
            };
    </script>
</body>
</html>
